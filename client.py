from message import *
from constants import *
from network_agent import NetworkAgent


class Client(NetworkAgent):
    def __init__(self, nickname: str, color: str):
        super().__init__()
        self.nickname = nickname
        self.color = color # hex nickname color
        self.command_queue = queue.Queue(10)
        self.reply_queue = queue.Queue(10)
        self.server_broadcast_queue = queue.Queue()
        self.ID = int() # determined by the server later
        self.server_public_key = tuple() # obtained later

    def write_to_chatbox(self):
        while self.running.is_set():
            message = self.server_broadcast_queue.get()
            #for now just print
            print(
                f"[SERVER BROADCAST] (Command: {message.code}",
                f"ID: {message.id})",
                f"{message._from}: {message.data}"
            )

    def handle_receive(self):
        while self.running.is_set():
            buffer = self.decrypt(
                self.receive(self.socket)
            )
            message = ClientMessage.unpack(buffer, self.hmac_key)
            if message.code == Command.ERROR:
                print(message)
            else:
                self.server_broadcast_queue.put(message)
    
    def handle_send(self, data: bytes):
        message = ClientMessage(Command.SEND, self.nickname, data.decode())
        self.send(
            self.socket,
            self.encrypt(message.pack(self.hmac_key))
        )

    def handle_connect(self, server_ip, server_port):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.address = self.socket.connect((server_ip, server_port))
    
    def run(self):
        DEBUG = 1
        self.handle_connect(SERVER_IP, SERVER_PORT)
        self.running.set()
        if DEBUG: print("[CLIENT] My public key:", self.public_key)

        # receive server public key
        buffer = self.receive(self.socket).decode().split("-")
        self.server_public_key = (int(buffer[0]), int(buffer[1]))
        if DEBUG: print("[CLIENT] Server public key:", self.server_public_key)
        
        # send public key to server
        self.send(
            self.socket,
            f"{self.public_key[0]}-{self.public_key[1]}".encode()
        )

        # receive encrypted fernet and HMAC keys
        self.fernet_key = self.rsa_decrypt_b(
                            self.receive(self.socket),
                            self.private_key
                        )
        if DEBUG: print("[CLIENT] Fernet key:", self.fernet_key)
        self.hmac_key = self.rsa_decrypt_b(
                            self.receive(self.socket),
                            self.private_key
                        )
        if DEBUG: print("[CLIENT] HMAC key:", self.hmac_key)

        # send ecrypted client data 
        initial_data =  json.dumps({
                            "nickname": self.nickname,
                            "color": self.color
                        })
        self.send(
            self.socket,
            self.rsa_encrypt_b(initial_data.encode(), self.server_public_key)
        )

        # receive ID generated by the server
        self.ID =   struct.unpack("<I",
                        self.decrypt(
                            self.receive(self.socket)
                        )
                    )[0]
        ClientMessage.CLIENT_ID = self.ID
        if DEBUG: print("[CLIENT] My ID:", self.ID)

        threading.Thread(target=self.write_to_chatbox, daemon=True).start()
        threading.Thread(target=self.handle_receive, daemon=True).start()


#for test purposes
if __name__ == "__main__":
    client = Client(input("Insert nickname: "), "blue")
    
    threading.Thread(target=client.run, daemon=True).start()

    while True:
        time.sleep(0.3)
        msg = input("> ")
        client.handle_send(msg.rstrip().encode())